#include <concepts>
#include <string>

#include <forward_list>
#include <list>
#include <vector>
#include <unordered_set>
#include <iostream>

#include <type_traits>

#include <compare>
using namespace std;

class MyInt {
public:
  constexpr explicit MyInt(int val): value{val} { }
  
  bool operator == (const MyInt& rhs) const
  {
    std::cout << "== " << '\n';
    return value == rhs.value;
  }
  
  bool operator < (const MyInt& rhs) const
  {
    std::cout << "< " << '\n';
    return value < rhs.value;
  }

  auto operator<=>(const MyInt& rhs) const = default;

private:
  int value;
};

int main()
{
  cout <<std::boolalpha ;
  MyInt myInt2011(2011);
  MyInt myInt2014(2014);

  myInt2011 == myInt2014; // use user-defined ==
  myInt2011 != myInt2014; // use user-defined ==
  myInt2011 < myInt2014;  // use user-defined <
  myInt2011 <= myInt2014; // use auto-generated by compiler
  myInt2011 > myInt2014; // use auto-generated by compiler
  myInt2011 >= myInt2014; // use auto-generated by compiler

  /*
   * [1] By defaulting the operator <=>, the compiler autogenerates the six
   * comparison operators. The compiler-generated comparison operators
   * apply lexicographical comparison: all base classes are compared left
   * to right and all non-static members of the class in their declaration
   * order.
   *
   * [2] When auto-generated comparison operators and user-defined comparison
   * operators are both present, the user-defined comparison
   * operators have a higher priority.
   *
   * [3] The compiler rewrites expressions to take care of the symmetry of
   * the comparison operators. For example if (a <=> b) < 0 does not
   * work, the compiler generates 0 < (b <=> a).
   */
  return 0;
}
